<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>シャカシャカ・ラメ</title>
    <style>
        html, body { margin: 0; padding: 0; width: 100%; height: 100%; overflow: hidden; position: fixed; background: #1a1a1a; touch-action: none; }
        /* ラメ用のキャンバスを背面に配置 */
        #glitterCanvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 1; pointer-events: none; }
        .box { position: absolute; will-change: transform; left: 0; top: 0; cursor: grab; display: none; filter: drop-shadow(0 4px 8px rgba(0,0,0,0.5)); z-index: 10; }
        .box img { width: 100%; height: auto; display: block; pointer-events: none; user-select: none; }
        button { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); padding: 20px 40px; font-size: 20px; z-index: 10000; border-radius: 50px; border: none; background: #fff; color: #333; cursor: pointer; font-weight: bold; }
        .controls { position: absolute; top: 10px; right: 10px; z-index: 20000; display: none; gap: 8px; }
        .ctrl-btn { position: static; transform: none; padding: 10px 15px; font-size: 14px; background: rgba(255, 255, 255, 0.2); color: white; border: 1px solid rgba(255,255,255,0.3); border-radius: 5px; cursor: pointer; backdrop-filter: blur(4px); }
    </style>
</head>
<body>
    <canvas id="glitterCanvas"></canvas>
    <button id="startBtn">スタート</button>
    <div id="controls" class="controls">
        <button id="addBtn" class="ctrl-btn">もう10連</button>
        <button id="resetBtn" class="ctrl-btn">↻</button>
    </div>

    <script>
        const size = 150;        
        const smallSize = 100;   
        const gachaCount = 10;   
        
        // ふんわり設定
        const FRICTION = 0.96;      
        const ROT_FRICTION = 0.95; 
        const BOUNCE = 0.6;        
        const GRAVITY = 0.08; 

        let boxes = []; 
        let glitters = []; // ラメ用配列
        const canvas = document.getElementById('glitterCanvas');
        const ctx = canvas.getContext('2d');

        const btn = document.getElementById('startBtn');
        const controls = document.getElementById('controls');
        const addBtn = document.getElementById('addBtn');
        const resetBtn = document.getElementById('resetBtn');

        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        window.addEventListener('resize', resize);
        resize();

        // ラメの作成
        function createGlitter() {
            for(let i=0; i<150; i++) {
                glitters.push({
                    x: Math.random() * canvas.width,
                    y: Math.random() * canvas.height,
                    vx: (Math.random() - 0.5) * 2,
                    vy: (Math.random() - 0.5) * 2,
                    size: Math.random() * 2 + 1,
                    color: `hsla(${Math.random() * 60 + 180}, 80%, 80%, ${Math.random() * 0.8 + 0.2})`, // 青〜白系のキラキラ
                    phase: Math.random() * Math.PI * 2
                });
            }
        }

        function pickGachaImage() {
            const rand = Math.random() * 100;
            if (rand < 6) return 6;        
            if (rand < 16) return 5;   
            return 4;                      
        }

        function getGachaZIndex() {
            return Math.random() < 0.33 ? 110 : 10;
        }

        function createBox(imgNum, currentWidth, zIndex, isInitial = false) {
            const div = document.createElement('div');
            div.className = 'box';
            div.style.width = currentWidth + 'px';
            div.style.zIndex = zIndex; 
            const img = new Image();
            img.src = `${imgNum}.png`;
            div.appendChild(img);
            document.body.appendChild(div);

            const data = {
                el: div, img: img, px: 0, py: 0, vx: 0, vy: 0, 
                angle: Math.random() * 360, va: 0,
                w: currentWidth, h: 0,
                isDragging: false,
                isInitial: isInitial,
                initialZ: zIndex
            };
            img.onload = () => { data.h = currentWidth * (img.naturalHeight / img.naturalWidth); };
            
            div.addEventListener('touchstart', (e) => { 
                data.isDragging = true; 
                div.style.zIndex = 10000;
                e.preventDefault(); 
            }, {passive: false});

            window.addEventListener('touchmove', (e) => {
                if (!data.isDragging) return;
                let touch = e.touches[0];
                let lastX = data.px;
                let lastY = data.py;
                data.px = touch.clientX - (data.w / 2);
                data.py = touch.clientY - (data.h / 2);
                data.vx = data.px - lastX; 
                data.vy = data.py - lastY;
                data.angle = data.vx * 1.5; 
            }, {passive: false});

            window.addEventListener('touchend', () => { 
                if (!data.isDragging) return;
                data.isDragging = false; 
                div.style.zIndex = data.initialZ;
            });
            boxes.push(data);
            return data;
        }

        function dropBox(b) {
            b.px = Math.random() * (window.innerWidth - b.w);
            b.py = -200 - (Math.random() * 400); 
            b.vx = (Math.random() - 0.5) * 10;
            b.vy = 2 + Math.random() * 3;
            b.el.style.display = 'block';
        }

        for (let i = 1; i <= 3; i++) createBox(i, i <= 2 ? size : smallSize, 100 + i, true);
        for (let i = 0; i < gachaCount; i++) createBox(pickGachaImage(), smallSize, getGachaZIndex(), true);

        btn.onclick = () => {
            createGlitter();
            boxes.forEach(b => dropBox(b));
            if (typeof DeviceMotionEvent.requestPermission === 'function') {
                DeviceMotionEvent.requestPermission().then(run);
            } else { run(); }
            btn.style.display = 'none';
            controls.style.display = 'flex';
        };

        addBtn.onclick = () => {
            for (let i = 0; i < 10; i++) {
                const newBox = createBox(pickGachaImage(), smallSize, getGachaZIndex(), false);
                dropBox(newBox);
            }
        };

        resetBtn.onclick = () => {
            boxes.forEach(b => {
                if (!b.isInitial) b.el.remove();
                else {
                    if (b.img.src.match(/[4-6]\.png$/)) b.img.src = `${pickGachaImage()}.png`;
                    dropBox(b);
                }
            });
            boxes = boxes.filter(b => b.isInitial);
        };

        function run() {
            const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) || (navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1);
            const flip = isIOS ? -1 : 1;

            let accelX = 0, accelY = 0;
            window.addEventListener("devicemotion", (e) => {
                let ag = e.accelerationIncludingGravity;
                if(!ag || ag.x === null) return;
                accelX = ag.x * 0.2 * flip;
                accelY = ag.y * 0.2 * flip;
                boxes.forEach(b => { 
                    if (!b.isDragging) {
                        b.vx -= accelX; b.vy += accelY;
                    }
                });
            });

            function update() {
                // ラメの描画
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                glitters.forEach(g => {
                    g.vx += (accelX * -0.1); // 傾きでラメも流れる
                    g.vy += (accelY * 0.1) + GRAVITY * 0.5;
                    g.vx *= 0.98; g.vy *= 0.98;
                    g.x += g.vx; g.y += g.vy;
                    g.phase += 0.05;

                    if(g.x < 0) g.x = canvas.width;
                    if(g.x > canvas.width) g.x = 0;
                    if(g.y > canvas.height) g.y = 0;

                    const opacity = (Math.sin(g.phase) + 1) / 2;
                    ctx.fillStyle = g.color;
                    ctx.globalAlpha = opacity;
                    ctx.beginPath();
                    ctx.arc(g.x, g.y, g.size, 0, Math.PI*2);
                    ctx.fill();
                });
                ctx.globalAlpha = 1.0;

                // 物理演算
                for (let step = 0; step < 4; step++) {
                    for (let i = 0; i < boxes.length; i++) {
                        for (let j = i + 1; j < boxes.length; j++) {
                            let a = boxes[i], b = boxes[j];
                            if (a.h === 0 || b.h === 0) continue;
                            let dx = (b.px + b.w/2) - (a.px + a.w/2);
                            let dy = (b.py + b.h/2) - (a.py + a.h/2);
                            let dist = Math.sqrt(dx * dx + dy * dy) || 1;
                            let minDist = (a.w + b.w) * 0.47;
                            if (dist < minDist) {
                                let overlap = minDist - dist;
                                let nx = dx / dist, ny = dy / dist;
                                let rvx = b.vx - a.vx, rvy = b.vy - a.vy;
                                let velAlongNormal = rvx * nx + rvy * ny;
                                if (velAlongNormal < 0) {
                                    let j_impulse = -(1 + BOUNCE) * velAlongNormal * 0.5;
                                    if (!a.isDragging) { a.vx -= nx * j_impulse; a.vy -= ny * j_impulse; }
                                    if (!b.isDragging) { b.vx += nx * j_impulse; b.vy += ny * j_impulse; }
                                }
                                let moveX = nx * overlap * 0.5, moveY = ny * overlap * 0.5;
                                if (!a.isDragging) { a.px -= moveX; a.py -= moveY; }
                                if (!b.isDragging) { b.px += moveX; b.py += moveY; }
                            }
                        }
                    }
                }

                boxes.forEach(b => {
                    if (!b.isDragging) {
                        if (Math.abs(b.vx) < 0.2 && Math.abs(b.vy) < 0.2) { b.vx = 0; b.vy = 0; b.va = 0; } 
                        else { b.vy += GRAVITY; }
                        b.vx *= FRICTION; b.vy *= FRICTION; b.va *= ROT_FRICTION;
                        b.px += b.vx; b.py += b.vy; b.angle += b.va;
                        const rw = window.innerWidth - b.w, bh = window.innerHeight - b.h;
                        if (b.px < 0) { b.px = 0; b.vx *= -BOUNCE; }
                        if (b.px > rw) { b.px = rw; b.vx *= -BOUNCE; }
                        if (b.py > bh) { b.py = bh; b.vy *= -BOUNCE; }
                    }
                    b.el.style.transform = `translate(${b.px}px, ${b.py}px) rotate(${b.angle}deg)`;
                });
                requestAnimationFrame(update);
            }
            update();
        }
    </script>
</body>
</html>
